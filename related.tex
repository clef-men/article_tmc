\section{Related work}

\subsection{TMC support in compilers}

Tail-recursion modulo cons was well-known in the Lisp community as
early as the 1970s. For example the REMREC system~\citep*{risch-73}
would automatically transform recursive functions into loops, and
supports modulo-cons tail recursion. It also supports tail-recursion
modulo associative arithmetic operators, which is outside the scope
of our work, but supported by the GCC compiler for example. The TMC
fragment is precisely described (in prose) in \citet*{friedman-wise-75}.

In the Prolog community it is a common pattern to implement
destination-passing style through unification variables; in particular
``difference lists'' are a common representation of lists with a final
hole. Unification variables are first-class values, in particular they
can be passed as function arguments. This makes it easy to write the
destination-passing-style equivalent of a context of the form
\ocaml{List.append li _?}, as the difference list
\ocaml{(List.append li X, X)}. In constrast, we only support direct
constructor applications. However, this expressivity comes at
a performance cost, and there is no static checking that the data is
fully initialized at the end of computation.

\subsection{Reasoning about destination-passing-style}

In general, if we think of non-tail recursive functions as having an
``evaluation context'' left for after the recursive call, then the
techniques to turn classes of calls into tail-calls correspond to
different reified representations of non-tail contexts, as long as
they support efficient composition and hole-plugging. TMC comes from
representing data-construction contexts as the partial data itself,
with hole-plugging by mutation. Associative-operator transformations
represent the context \ocaml|1 + (4 + _?)| as the number \ocaml|5|
directly. (Sometimes it suffices to keep around an abstraction of the
context; this is a key idea in John Clements' work on stack-based
security in presence of tail calls.)

\cite*{minamide-98} gives a ``functional'' interface to
destination-passing-style program, by presenting a partial
data-constructor composition \ocaml{Foo(x,Bar(_?))} as a use-once,
linear-typed function \ocaml{linfun h -> Foo(x,Bar(h))}. Those special
linear functions remain implemented as partial data, but they expose
a referentially-transparent interface to the programmer, restricted by
a linear type discline. This is a beautiful way to represent
destination-passing style, orthogonal to our work: users of Minamide's
system would still have to write the transformed version by hand, and
we could implement a transformation into destination-passing style
expressed in his system. \citet*{mezzo-2016}
supports a more general-purpose type system based on separation logic,
which can directly express uniquely-owned partially-initialized data,
and its implicit transformation into immutable, duplicable
results. (See the
\href{https://protz.github.io/mezzo/code_samples/list.mz.html}{List}
module of the Mezzo standard library, and in particular \ocaml{cell},
\ocaml{freeze} and \ocaml{append} in destination-passing-style).

\Xgabriel{TODO: Leijen and Lorenzen}

\subsection{Relational reasoning in separation logic}

% + ReLoC Reloaded: A Mechanized Relational Logic for Fine-Grained Concurrency and Logical Atomicity
% + A Higher-Order Logic for Concurrent Termination-Preserving Refinement
% + Transfinite Iris: Resolving an Existential Dilemma of Step-Indexed Separation Logic
% + Simuliris: A Separation Logic Framework for Verifying Concurrent Program Optimizations

\subsection{Protocols}

% + Compiler Verification Meets Cross-Language Linking via Data Abstraction
%   axiomatic semantics are close to protocols in spirit, they include in the
%   syntactic reasoning rules an "axiomatic" step that non-deterministically
%   reduces a function call following a (P,Q) pre/post
% + A Separation Logic for Effect Handlers
%   we were inspired by Paulo: Χ allows do v { Φ }
%     + specification of an effect
%     + protocol Χ allows the program to perform the effect v and garantees that every permitted reply satisfies postcondition Φ
%     + "we would like programmers to think about performing an effect essentially in the same way as they think about calling a function"
%     + wp parameterized by protcol: ewp e < Χ > { Φ }
% + Melocoton: A Program Logic for Verified Interoperability Between OCaml and C


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
