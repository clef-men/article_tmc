\section{Related work}

\subsection{TMC support in compilers}

Tail-recursion modulo cons was well-known in the Lisp community as
early as the 1970s. For example the REMREC system~\citep*{risch-73}
would automatically transform recursive functions into loops, and
supports modulo-cons tail recursion. It also supports tail-recursion
modulo associative arithmetic operators, which is outside the scope
of our work, but supported by the GCC compiler for example. The TMC
fragment is precisely described (in prose) in \citet*{friedman-wise-75}.

In the Prolog community it is a common pattern to implement
destination-passing style through unification variables; in particular
``difference lists'' are a common representation of lists with a final
hole. Unification variables are first-class values, in particular they
can be passed as function arguments. This makes it easy to write the
destination-passing-style equivalent of a context of the form
\ocaml{List.append li _?}, as the difference list
\ocaml{(List.append li X, X)}. In constrast, we only support direct
constructor applications. However, this expressivity comes at
a performance cost, and there is no static checking that the data is
fully initialized at the end of computation.

Independently of our work, Koka has implemented TMC starting in August
2020\footnote{https://github.com/koka-lang/koka/commit/f6a343d31f486ea5edd44798dca7bca52d7b450c}~\citep*{tmc-koka-2023}.
An interesting problem they had to solve, which does not occur in OCaml,
is how to support TMC in presence of non-linear contibuations. Our
correctness argument for TMC relies on the fact that the destination
is uniquely owned, and written exactly once; this property may not
hold in programs that use multishot continuations (\ocaml|call/cc|,
\ocaml|let/cc|, \ocaml|delim/cc|). The standard Koka runtime uses its
reference-counting machinery to determine that a destination is not
uniquely-owned anymore, and stores extra metadata in
partially-initialized blocks to be able to copy them on-demand in this
case. Its Javascript backend instead reverts to a CPS transformation
when non-linear control flow is detected.

\subsection{Reasoning about destination-passing-style}

In general, if we think of non-tail recursive functions as having an
``evaluation context'' left for after the recursive call, then the
techniques to turn classes of calls into tail-calls correspond to
different reified representations of non-tail contexts, as long as
they support efficient composition and hole-plugging. TMC comes from
representing data-construction contexts as the partial data itself,
with hole-plugging by mutation. Associative-operator transformations
represent the context \ocaml|1 + (4 + _?)| as the number \ocaml|5|
directly. (Sometimes it suffices to keep around an abstraction of the
context; this is a key idea in John Clements' work on stack-based
security in presence of tail calls.)

\citet*{minamide-98} gives a ``functional'' interface to
destination-passing-style program, by presenting a partial
data-constructor composition \ocaml{Foo(x,Bar(_?))} as a use-once,
linear-typed function \ocaml{linfun h -> Foo(x,Bar(h))}. Those special
linear functions remain implemented as partial data, but they expose
a referentially-transparent interface to the programmer, restricted by
a linear type discline. This is a beautiful way to represent
destination-passing style, orthogonal to our work: users of Minamide's
system would still have to write the transformed version by hand, and
we could implement a transformation into destination-passing style
expressed in his system. Mezzo~\citep*{mezzo-2016}
supports a more general-purpose type system based on separation logic,
which can directly express uniquely-owned partially-initialized data,
and its implicit transformation into immutable, duplicable
results. (See the
\href{https://protz.github.io/mezzo/code_samples/list.mz.html}{List}
module of the Mezzo standard library, and in particular \ocaml{cell},
\ocaml{freeze} and \ocaml{append} in destination-passing-style).

\citet*{tmc-koka-2023} provide a (pen-and-paper) correctness argument
for TMC, or in fact a family of approaches based on optimized
representations of classes of non-tail contexts, in the style of
program calculation. The clarity of their exposition is
remarkable. The implementation they prove correct, which corresponds
to the approach described in \citet*{minamide-98}, results in
a slightly different code generation where recursive calls to
\ocaml{map_dps} are passed \emph{both} the beginning of the list and
the destination to be written at its end. The beginning of the list
remains constant over all recursive calls, and it is known to the
caller, so our DPS version does not propagate it. We were inspired by
the generality of their presentation and verified that our proof
technique can also be applied to some over TMC variants, by extending
our mechanized development with a correctness proof for an
accumulator-passing-style transformation.

\subsection{Relational reasoning in separation logic}

% + ReLoC Reloaded: A Mechanized Relational Logic for Fine-Grained Concurrency and Logical Atomicity
% + A Higher-Order Logic for Concurrent Termination-Preserving Refinement
% + Transfinite Iris: Resolving an Existential Dilemma of Step-Indexed Separation Logic
% + Simuliris: A Separation Logic Framework for Verifying Concurrent Program Optimizations

\subsection{Protocols}

% + Compiler Verification Meets Cross-Language Linking via Data Abstraction
%   axiomatic semantics are close to protocols in spirit, they include in the
%   syntactic reasoning rules an "axiomatic" step that non-deterministically
%   reduces a function call following a (P,Q) pre/post
% + A Separation Logic for Effect Handlers
%   we were inspired by Paulo: Χ allows do v { Φ }
%     + specification of an effect
%     + protocol Χ allows the program to perform the effect v and garantees that every permitted reply satisfies postcondition Φ
%     + "we would like programmers to think about performing an effect essentially in the same way as they think about calling a function"
%     + wp parameterized by protcol: ewp e < Χ > { Φ }
% + Melocoton: A Program Logic for Verified Interoperability Between OCaml and C


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
