Common implementations of functional programming languages incentivize tail-recursive function definitions, as opposed to general recursive functions that consume stack space and may not scale to large inputs.
%
This distinction occasionally requires writing functions in a tail-recursive style that may be more complex and slower than the natural, non-tail-recursive definition.

This work describes our implementation of the \emph{tail modulo constructor} (TMC) transformation in the OCaml compiler, a compilation strategy that provides stack-efficiency for a larger class of functions -- tail-recursive \emph{modulo constructors} -- which include in particular the natural definition of \ocaml{List.map} and many similar recursive data-constructing functions.

We prove the correctness of this program transformation in a simplified setting -- a small untyped calculus -- that captures the salient aspects of the OCaml implementation. Our proof is mechanized in the Coq proof assistant, using the Iris base logic. An independent contribution of our work is a extension of the Simuliris approach to define simulation relations that support different calling conventions. To our knowledge, this is the first use of a simulation relation defined in Iris to prove the correctness of a compiler transformation.
