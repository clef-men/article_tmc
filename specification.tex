\section{Understanding and specifying TMC}
\label{sec:specification}

\subsection{Direct transformation}

\subsection{DPS transformation}

% uniquely-owned mutable state.

\subsection{Heap bijection}

% SimBijInsert: \approx^bij: Simuliris calls this the escaped/public
% locations, those that have been published.

% ---------------------------------------------------------

spécification des deux transformées pour une certaine notion de similarité entre valeurs

définition de la similarité entre valeurs (évolution tas)

% ---------------------------------------------------------

%\begin{theorem}[Specification of direct transformation]
%    \[
%        \iRsimvHoare{
%            \wf{\datalangExpr_s} \iSep
%            \datalangExpr_s \tmcDir{\datalangRenaming} \datalangExpr_t
%        }{
%            \iSimilar
%        }{
%            \datalangExpr_s
%        }{
%            \datalangExpr_t
%        }
%    \]
%\end{theorem}
%
%\begin{theorem}[Specification of DPS transformation]
%    \[
%        \iRsimvHoare{
%            \wf{\datalangExpr_s} \iSep
%            (\datalangLoc, \datalangIdx, \datalangExpr_s) \tmcDps{\datalangRenaming} \datalangExpr_t \iSep
%            (\datalangLoc + \datalangIdx) \iPointsto \datalangHole
%        }{
%            \lambdaAbs (\datalangVal_s, \datalangVal_t') \ldotp
%            \exists \datalangVal_t \ldotp
%            \datalangVal_t' = \datalangUnit \iSep
%            (\datalangLoc + \datalangIdx) \iPointsto \datalangVal_t \iSep
%            \datalangVal_s \iSimilar \datalangVal_t
%        }{
%            \datalangExpr_s
%        }{
%            \datalangExpr_t
%        }
%    \]
%\end{theorem}

% ---------------------------------------------------------

%The separation logic in which our reasoning rules are formulated is relational: it describes resources from a source and target programs and relations between them. We use the following primitive assertions:
%
%\begin{itemize}
%\item $\datalangLoc_s \iPointsto_s \datalangVal_s$, a points-to assertion for the source program
%\item $\datalangLoc_t \iPointsto_t \datalangVal_t$, for the target program
%\item $\datalangLoc_s \iInBij \datalangLoc_t$, which asserts that the source location $\datalangLoc_s$ and the target location $\datalangLoc_t$ are in the ``heap bijection''. This assertion is persistent: one cannot remove locations from the bijection.
%\end{itemize}
%
%On top of these assertions we define a \emph{value similarity} relation $\datalangVal_s \iSimilar \datalangVal_t$, given in Figure~\ref{fig:isimilar}.  Except for locations, this is exactly the equality. For locations, notice that locations appearing during the reduction of our programs are locations of valid blocks (always of size 3 in our language). We relate them by asking their field locations to be in the heap bijection.

% ---------------------------------------------------------

%\subsection{The quest for the right notion of simulation}
%\label{sec:howto-relation}
%
%The final theorem we want to establish is a behaviour refinement $\datalangProg_s \refined \datalangProg_t$: the behaviours of the transformed program are included in the behaviour of the source program.
%%
%We propose a notion of behaviour refinement that gives a form of total correctness.
%%
%It is termination-preserving, but also (this is less common in the body of work around Iris) safety-preserving and divergence-preserving.
%
%We prove this using a backward simulation argument for our transformations $\datalangExpr_s \tmc \datalangExpr_t$.
%%
%A direct approach, ultimately unsucessful, would be to prove that the relation is in the simulation by induction, on $\datalangExpr_s$ for example.
%%
%This works well for all constructions except for function calls $\datalangCall{\datalangFnptr{\datalangFn}}{\datalangExpr}$: to reason on the relation between a call to $\datalangFnptr{\datalangFn}$ and its transformation (in direct or DPS style), we would need to inline the function definition, which is not structurally decreasing.
%
%This is a common problem to establish simulations, and the solution is to use a form of co-induction.
%%
%In the Iris logic, a natural way to do this would be to use a ``later'' modality.
%%
%But defining simulations using a ``later'' modality is in fact non-trivial; simple definitions do not give the excepted notion of simulation, due to non-intuitive aspects of the step-indexing semantics of ``later'' in the Iris model. This problem is discussed in details in the previous work on Transfinite Iris~\citep*{TODO-transfinite-Iris}, an alternative logic with different axioms and models.
%%
%Sticking to the main Iris logic, a good definition of simulation has been worked out in Simuliris~\citep*{TODO-Simuliris}.
%%
%It avoids using the ``later'' modality by using the notion of coinduction native to Coq. In Simuliris, coinductive reasoning steps correspond to an ``abstract'' case in the simulation relation, used for function applications; an ``open simulation'' allows these abstract steps, while a ``closed simulation'' does not allow them.
%%
%The coinduction principle is encapsulated in a ``simulation closure'' theorem, which states if two terms are related in the open simulation, they are in fact also related in the closed simulation if we (coinductively) assume that foreign function bodies are correct.
%
%Our proof is heavily inspired by the Simuliris work, but we cannot reuse their results directly because the notion of simulation that they provide is not expressive enough for our proof: we need to support transformations that change the calling conventions between source and target programs.
%%
%(Along the way we also simplified the simulation relation by removing proof rules related to concurrency, which we do not consider in this work.)
%
%To support different calling conventions, we make our simulation relation $\iSim[\iProt]{\iPred}{\datalangExpr_s}{\datalangExpr_t}$ parametric over abstract protocols $\iProt$. This extends the technique of \citet*{TODO-paulo} from the unary setting of safety predicates to the binary setting of a relational separation logic.
%
%\subsection{Proof outline}
%
%Once we have decided to reuse and extend the Simuliris work, our argument can be split in three separate parts:
%
%\begin{enumerate}
%
%\item Define our notion of simulation parametric over protocols (calling conventions), prove its adequacy (it implies a behaviour refinement) and establish a ``closure theorem'' as in the Simuliris work.
%%
%  This technical contribution is independent of the TMC language or transformation, and could be reused in other works.
%
%\item Build a relational program logic for our programming language, as a body of lemmas to establish simulations between expressions.
%
%\item Use this program logic to establish the soundness of the TMC transformation.
%%
%The key ingredients are two specifications for the direct and DPS transformations that are proved in a mutually-inductive way, and are used to prove the hypothesis of the closure theorem of our simulation.
%\end{enumerate}

% ---------------------------------------------------------

\input{figures/isimilar}
%\input{figures/heap_bij}