\section{Understanding and specifying TMC}
\label{sec:specification}

Before proving anything about TMC, we have to understand it.
In this section, we show that there is a simple way to describe the essence of the transformation.
The core idea is to give intuitive specifications to the direct and DPS sub-transformations using \emph{separation logic}.
In the next sections, we will unroll the proof of these specifications and extract a soundness theorem that lives outside of separation logic, depending only on the \DataLang semantics.

\subsection{Direct transformation}

Intuitively, the direct transformation $\datalangExpr_s \tmcDir{\datalangRenaming} \datalangExpr_t$ preserves the behaviours of the source expression $\datalangExpr_s$.
Basically, $\datalangExpr_s$ and $\datalangExpr_t$ compute the same thing.
Using \emph{relational Hoare logic}, an assumed extension of standard Hoare logic relating two expressions, we would write:
\[
    \iSimvHoare{
        \datalangExpr_s \tmcDir{\datalangRenaming} \datalangExpr_t
    }{
        \datalangVal_s, \datalangVal_t \ldotp
        \datalangVal_s \iSimilar \datalangVal_t
    }{
        \datalangExpr_s
    }{
        \datalangExpr_t
    }
\]

The informal meaning of this specification is that 1) $\datalangExpr_t$ refines $\datalangExpr_s$ in the sense that any behaviour (converging, diverging or stuck execution) of $\datalangExpr_t$ is also a behaviour of $\datalangExpr_s$ and 2) if $\datalangExpr_t$ converges to value $\datalangVal_t$, $\datalangExpr_s$ also converges to some value $\datalangVal_s$ that is \emph{similar} to $\datalangVal_s$.
We will formalize the notion of \emph{behaviour} in \cref{sec:simulation} and that of \emph{similarity} later in this section.
For the time being, the ready may assume similarity is just equality on values.

\subsection{DPS transformation}

The DPS transformation $(\datalangLoc, \datalangIdx, \datalangExpr_s) \tmcDps{\datalangRenaming} \datalangExpr_t$ is parameterized by a destination $(\datalangLoc, \datalangIdx)$ pointing to an uninitialized field of some block.
Intuitively, $\datalangExpr_t$ computes the same thing as $\datalangExpr_s$ but writes it into the destination instead of returning it.
Using \emph{relational separation logic}, an assumed further extension of relational Hoare logic with the concepts of separation logic, we would write:
\[
    \iSimvHoare{
        (\datalangLoc, \datalangIdx, \datalangExpr_s) \tmcDps{\datalangRenaming} \datalangExpr_t \iSep
        (\datalangLoc + \datalangIdx) \iPointsto_t \datalangHole
    }{
        \datalangVal_s, \datalangUnit \ldotp
        \exists \datalangVal_t \ldotp
        (\datalangLoc + \datalangIdx) \iPointsto_t \datalangVal_t \iSep
        \datalangVal_s \iSimilar \datalangVal_t
    }{
        \datalangExpr_s
    }{
        \datalangExpr_t
    }
\]

The \emph{points-to assertion} $(\datalangLoc + \datalangIdx) \iPointsto_t -$ expresses that the destination is uniquely owned by the transformed program.
The specification requires $\datalangExpr_t$ to fill it with some value that is similar to the returned source value.
In simple terms, this is essentially the specification of destination-passing style.

\subsection{Heap bijection}

While we assumed value similarity to be just equality, it is actually not sufficient.
Indeed, corresponding source and target block locations are not synchronized.
To see why, consider the \datalang{map} function (\cref{fig:map}) and its DPS transform (\cref{fig:map_tmc}).
Notice that \datalang{dst'} corresponds with the returned source block \datalang{y :: @map (fn, xs)} but is allocated before the recursive call.
In other words, the transformed program \emph{allocates ahead} of the source program.

To deal with this, we introduce a \emph{heap bijection} as in \Simuliris~\cite{DBLP:journals/pacmpl/GaherSSJDKKD22}.
Corresponding source and target locations --- pointing to block fields in our semantics --- are logically and permanently registered in this bijection. 
We can then refer to a registered pair of locations though the assertion $\datalangLoc_s \iInBij \datalangLoc_t$.
This mechanism is formalized by the \RefTirName{BijInsert} rule:

\begin{mathpar}
    \inferrule*[lab=BijInsert]
        {
            \datalangLoc_s \iPointsto_s \datalangVal_s
        \and
            \datalangLoc_t \iPointsto_t \datalangVal_t
        \and
            \datalangVal_s \iSimilar \datalangVal_t
        }{
            \datalangLoc_s \iInBij \datalangLoc_t
        }
\end{mathpar}

Finally, we define value similarity in \cref{fig:isimilar}.
It coincides with equality except on blocks, for which we require all fields to be registered in the bijection.

\input{figures/isimilar}