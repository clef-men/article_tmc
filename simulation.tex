\section{Simulation}
\label{sec:simulation}

% ---------------------------------------------------------

%Simuliris~\citep*{TODO-simuliris} suggests a definition of simulation relations in Iris. As we explained in \cref{sec:howto-relation}, it carefully avoids using the ``later'' modality by using Coq's native notion of coinduction. Simuliris has several desirable properties for us: it can be defined in the un-modified Iris base logic (unlike Transfinite Iris~\citep*{transfinite-iris}), it is defined in a way that makes it easy to specialize to other programming languages, and it supports showing the preservation of termination. On the other hand, the original definition is complex as it supports concurrency and notions of fairness. We reused the definition of Simuliris, simplified for the sequential setting. We then extended the resulting definition to support our treatment of stuck states as failures, and generalize the notion of external calls to abstract protocols $\iProt$. Most of the ideas below come from the Simuliris work directly, we will explicitly point out the parts that differ.
%
%\paragraph{Relating states} The \emph{state interpretation} $I(\datalangState_s, \datalangState_t)$ relates source and target states. It extends the unary notion of state interpretation predicate $I(\datalangState)$. Recall that in separation logic, formulas contain both pure propositions and ressources, which include in particular logical points-to assertions $\datalangLoc \iPointsto v$. $I(\datalangState)$ enforces the consistency between those logical assertions and the physical state $\datalangState$.
%
%In the relational setting, the state interpretation becomes a relation $I(\datalangState_s, \datalangState_t)$ tracking points-to predicates on either states $\datalangLoc_s \iPointsto_s \datalangVal_s$ and $\datalangLoc_t \iPointsto_t \datalangVal_t$. It is additionally in charge of maintaining the heap bijection mentioned in \cref{TODO} by tracking predicates $\datalangLoc_s \iInBij \datalangLoc_t$. This assertion is persistent: one cannot remove locations from the bijection.
%
%\paragraph{Relating values} TODO relation between values.
%
%\paragraph{Relating expressions} The definition of the expression relation $\iSim[\iProt]{\iPred}{\datalangExpr_s}{\datalangExpr_t}$ is shown in \cref{fig:sim}; it reads as ``$\datalangExpr_s$ simulates $\datalangExpr_t$ under the postcondition $\iPred$ and protocol $\iProt$''. It expresses that the source $\datalangExpr_s$ can simulate any computation of the target $\datalangExpr_t$ until they both get stuck, both diverge, or reach two expressions in the relational post-condition $\iPred$. The parameter $\iProt$ is the relational protocol that must be followed by function calls in $\datalangExpr_s$ and $\datalangExpr_t$ -- generalizing the Simuliris rule for external calls.
%
%\paragraph{Mixed induction and coinduction}
%The definition of the relation itself starts with a double fixpoint, a greatest fixpoint $\nuAbs sim .$ (coinduction) of smallest fixpoint $\muAbs {sim \mathhyphen inner} .$ (induction) of a relation $\mathrm{sim \mathhyphen body}_\iProt$. Inside the relation definition, the cases that use the inductive $sim \mathhyphen inner$ in their recursive occurrence can only be repeated finitely many times, while the cases that use the coinductive $sim$ in their recursive occurrence can be repeated infinitely, but can only do so under a form of guardedness condition.
%
%\paragraph{Simulation clauses} The relation between $\datalangExpr_s$ and $\datalangExpr_t$, at a given post-condition $\iPred$, must be parametric over all physical states in the state interpretation relation $I(\datalangState_s, \datalangState_t)$. It is established by one of the following clauses:
%
%\begin{enumerate}
%\item[\circled{1}] Halting clause: $\datalangExpr_s$, $\datalangExpr_t$ can stop if they are already in the post-condition $\iPred$ -- and the states are still related.
%\item[\circled{2}]
%\item[\circled{3}]
%\item[\circled{4}]
%\item[\circled{5}]
%\end{enumerate}
%
%% sim-body:
%% cas 1, 2, 3, 4: on raconte
%% "ouverte" comprend un autre cas.
%% cas 5: les appels externes, protocoles (on raconte)
%
%\begin{theorem}[Close simulation]
%    \begin{align*}
%            &
%            \iPersistent \left(
%                \forall \iPredTwo, \datalangExpr_s, \datalangExpr_t \ldotp
%                \iProt (\iPredTwo, \datalangExpr_s, \datalangExpr_t) \iSepImp
%                \mathrm{sim \mathhyphen inner}_\bot (\lambdaAbs (\_, \datalangExpr_s', \datalangExpr_t') \ldotp \iSim[\iProt]{\iPredTwo}{\datalangExpr_s'}{\datalangExpr_t'}) (\bot, \datalangExpr_s, \datalangExpr_t)
%            \right) \iSepImp
%        \\
%            &
%            \iSim[\iProt]{\iPred}{\datalangExpr_s}{\datalangExpr_t} \iSepImp
%            \iSim[\bot]{\iPred}{\datalangExpr_s}{\datalangExpr_t}
%    \end{align*}
%\end{theorem}

%\subsection{Soundness theorem}
%
%The TMC transformation preserves the behaviours of programs in a strong sense.
%We expect terminating programs to remain terminating, diverging programs to remain diverging and failing programs (those that get stuck) to remain failing.
%
%To formalize it, we first define the notion of behaviour.
%
%we define in \cref{fig:refinement} the notions of behaviours and behaviour refinement as in \Simuliris~\cite{DBLP:journals/pacmpl/GaherSSJDKKD22}.
%TODO
%
%We define the set $\mathrm{behaviours}_{\datalangProg} (\datalangExpr)$ of behaviours of an expression $\datalangExpr$ within a program $\datalangProg$, starting from an empty store.
%The behaviour $\constr{Conv}(\datalangVal_s)$ indicates that $\datalangExpr$ can evaluate to $\datalangVal_s$.
%The behaviour $\constr{Conv}(\datalangExpr')$, when $\datalangExpr'$ is not a value, indicates that $\datalangExpr$ can reduce to a stuck configuration $(\datalangExpr', \datalangState)$.
%Finally, $\constr{Div}$ indicates that $\datalangProg$ can diverge.
%
%The refinement relation on behaviours $b_s \refined b_t$ then follows in a natural way: divergence refines divergence, any stuck expression refines any other stuck expression, and a value $\datalangVal_t$ refines $\datalangVal_s$ when they are related for a ground equivalence $\datalangVal_s \similar \datalangVal_t$, which is the equality for all value kinds, except for locations where it gives no information, as done in Simuliris.
%This equivalence of ground values could be used, for example, to argue for the correctness of a \texttt{main} function that takes and returns integer arguments.
%
%Note a difference to Simuliris: our refinement between stuck/failing behaviours is $\constr{Div} \refined \constr{Div}$, whereas Simuliris uses $\constr{Div} \refined b_t$: the Simuliris relation assumes that the input program is safe, never gets stuck, and the behaviour refinement thus allows a stuck source term to be refined by any target program. With our definition, a source program that only gets stuck must be transformed into a target program that only gets stuck.
%This property would not be desirable for C compilers that want to optimize aggressively assuming the absence of undefined behaviors, but it does capture a finer-grained property of our program transformation.
%
%Finally, an expression $\datalangExpr_t$ refines $\datalangExpr_s$ when all its behaviours are refined by a behaviour of $\datalangExpr_s$, and a program $\datalangProg_t$ refines $\datalangProg_s$ when calls to source functions on equivalent inputs are in the refinement relation.
%
%We can now state the main soundness theorem of our work, whose proof is spread over the rest of the present \cref{sec:soundness}.
%
%\begin{theorem}[Soundness]
%    $
%        \wf{\datalangProg_s} \wedge \datalangProg_s \tmc \datalangProg_t \implies
%        \datalangProg_s \refined \datalangProg_t
%    $
%\end{theorem}
%
%The condition $\wf{\datalangProg_s}$ guarantees that the input program $\datalangProg_s$ is well-scoped. Under this condition, we can consider the target programs $\datalangProg_t$ that are TMC transformations $\datalangProg_s \tmc \datalangProg_s$, and our theorem states that they refine $\datalangProg_s$ as expected.

%\begin{theorem}[Adequacy]
%    $
%        \left( \vdash \iSimv{\iSimilar}{\datalangExpr_s}{\datalangExpr_t} \right) \implies
%        \datalangExpr_s \refined \datalangExpr_t
%    $
%\end{theorem}

% ---------------------------------------------------------

% I(sigma, sigmaÂ´) is as in Simuliris, not given explicitly in the current document.
% the \approx^bij relation refers to a component of I (a bijection between addresses)
% that is an implicit parameter of the definitions.

% ---------------------------------------------------------

% If two expressions refine internally (thy are in the
% simulation relation), and go to the internal equivalence between
% values, then they refine externally (they are in the denotational
% refinement relation).

% This is similar to the Simuliris proof, simplified thanks to the absence
% of concurrency.

% ---------------------------------------------------------

\input{figures/sim}
\input{figures/similar}
\input{figures/refinement}