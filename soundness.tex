\section{Soundness}
\label{sec:soundness}

(This paragraph below probably rather belongs to the introduction. Abort.)

The formal contribution of our work is a mechanized soundness proof for the TMC transformation on a simplified programming language, exhibiting the salient parts of the actual transformation for OCaml.
%
The destination-passing style used by the TMC transformation critically relies on uniquely-owned mutable state.
%
It is thus natural to use separation logic as our specification language.

\subsection{The quest for the right notion of simulation}
\label{sec:howto-relation}

The final theorem we want to establish is a behaviour refinement $p_s \refined p_t$: the behaviours of the transformed program are included in the behaviour of the source program.
%
We propose a notion of behaviour refinement that gives a form of total correctness.
%
It is termination-preserving, but also (this is less common in the body of work around Iris) safety-preserving and divergence-preserving.

We prove this using a backward simulation argument for our transformations $e_s \tmc e_t$.
%
A direct approach, ultimately unsucessful, would be to prove that the relation is in the simulation by induction, on $e_s$ for example.
%
This works well for all constructions except for function calls $\lambdCall{\lambdFunc{f}}{e}$: to reason on the relation between a call to $\lambdFunc{f}$ and its transformation (in direct or DPS style), we would need to inline the function definition, which is not structurally decreasing.

This is a common problem to establish simulations, and the solution is to use a form of co-induction.
%
In the Iris logic, a natural way to do this would be to use a ``later'' modality.
%
But defining simulations using a ``later'' modality is in fact non-trivial; simple definitions do not give the excepted notion of simulation, due to non-intuitive aspects of the step-indexing semantics of ``later'' in the Iris model. This problem is discussed in details in the previous work on Transfinite Iris~\citep*{TODO-transfinite-Iris}, an alternative logic with different axioms and models.
%
Sticking to the main Iris logic, a good definition of simulation has been worked out in Simuliris~\citep*{TODO-Simuliris}.
%
It avoids using the ``later'' modality by using the notion of coinduction native to Coq. In Simuliris, coinductive reasoning steps correspond to an ``abstract'' case in the simulation relation, used for function applications; an ``open simulation'' allows these abstract steps, while a ``closed simulation'' does not allow them.
%
The coinduction principle is encapsulated in a ``simulation closure'' theorem, which states if two terms are related in the open simulation, they are in fact also related in the closed simulation if we (coinductively) assume that foreign function bodies are correct.

Our proof is heavily inspired by the Simuliris work, but we cannot reuse their results directly because the notion of simulation that they provide is not expressive enough for our proof: we need to support transformations that change the calling conventions between source and target programs.
%
(Along the way we also simplified the simulation relation by removing proof rules related to concurrency, which we do not consider in this work.)

To support different calling conventions, we make our simulation relation $\iSim[\Chi]{\Phi}{e_s}{e_t}$ parametric over abstract protocols $\Chi$. This extends the technique of \citet*{TODO-paulo} from the unary setting of safety predicates to the binary setting of a relational separation logic.

\subsection{Proof outline}

Once we have decided to reuse and extend the Simuliris work, our argument can be split in three separate parts:

\begin{enumerate}

\item Define our notion of simulation parametric over protocols (calling conventions), prove its adequacy (it implies a behaviour refinement) and establish a ``closure theorem'' as in the Simuliris work.
%
  This technical contribution is independent of the TMC language or transformation, and could be reused in other works.

\item Build a relational program logic for our programming language, as a body of lemmas to establish simulations between expressions.

\item Use this program logic to establish the soundness of the TMC transformation.
%
The key ingredients are two specifications for the direct and DPS transformations that are proved in a mutually-inductive way, and are used to prove the hypothesis of the closure theorem of our simulation.
\end{enumerate}

The rest of this section expands each step of the proof, providing the necessary technical details to follow the Coq formalization.

\subsection{End goal: behaviour refinement}

The TMC transformation preserves the behaviour of programs in a strong sense.
%
We expect terminating programs to remain terminating, diverging programs to remain diverging and failing programs (those that get 
stuck) to remain failing.

Our definitions of behaviours and behaviour refinement are given in \fref{fig:refinement}.
%
Our notion of behaviours follows the definitions of Simuliris~\citep*{TODO-simuliris}.
%
We define the set $\mathrm{behaviours}_p(e)$ of behaviours of an expression $e$ within a program $p$, starting from an empty store.
%
The behaviour $\constr{Conv}(v_s)$ indicates that $e$ can evaluate to $v_s$.
%
The behaviour $\constr{Conv}(e')$, when $e'$ is not a value, indicates that $e$ can reduce to a stuck configuration $(e', \sigma)$.
%
Finally, $\constr{Div}$ indicates that $e$ can diverge.

The refinement relation on behaviours $b_s \refined b_t$ then follows in a natural way: divergence refines divergence, any stuck expression refines any other stuck expression, and a value $v_t$ refines $v_s$ when they are related for a ground equivalence $v_s \similar v_t$, which is the equality for all value kinds, except for locations where it gives no information, as done in Simuliris.
%
This equivalence of ground values could be used, for example, to argue for the correctness of a \texttt{main} function that takes and returns integer arguments.

Note a difference to Simuliris: our refinement between stuck/failing behaviours is $\constr{Div} \refined \constr{Div}$, whereas Simuliris uses $\constr{Div} \refined b_t$: the Simuliris relation assumes that the input program is safe, never gets stuck, and the behaviour refinement thus allows a stuck source term to be refined by any target program. With our definition, a source program that only gets stuck must be transformed into a target program that only gets stuck.
%
This property would not be desirable for C compilers that want to optimize aggressively assuming the absence of undefined behaviors, but it does capture a finer-grained property of our program transformation.

Finally, an expression $e_t$ refines $e_s$ when all its behaviours are refined by a behaviour of $e_s$, and a program $p_t$ refines $p_s$ when calls to source functions on equivalent inputs are in the refinement relation.

\input{figures/similar}
\input{figures/refinement}

We can now state the main soundness theorem of our work, whose proof is spread over the rest of the present Section~\ref{sec:soundness}.

\begin{theorem}[Soundness]
    $
        \wf{p_s} \wedge p_s \tmc p_t \implies
        p_s \refined p_t
    $
\end{theorem}

The condition $\wf{p_s}$ guarantees that the input program $p_s$ is well-scoped. Under this condition, we can consider the target programs $p_t$ that are TMC transformations $p_s \tmc p_s$, and our theorem states that they refine $p_s$ as expected.

\subsection{Proof technique: Simuliris with protocols}

Simuliris~\citep*{TODO-simuliris} suggests a definition of simulation relations in Iris. As we explained in Section~\ref{sec:howto-relation}, it carefully avoids using the ``later'' modality by using Coq's native notion of coinduction. Simuliris has several desirable properties for us: it can be defined in the un-modified Iris base logic (unlike Transfite Iris~\citep*{transfinite-iris}), it is defined in a way that makes it easy to specialize to other programming languages, and it supports showing the preservation of termination. On the other hand, the original definition is complex as it supports concurrency and notions of fairness. We reused the definition of Simuliris, simplified for the sequential setting. We then extended the resulting definition to support our treatment of stuck states as failures, and generalize the notion of external calls to abstract protocols $\Chi$. Most of the ideas below come from the Simuliris work directly, we will explicitly point out the parts that differ.

The definition of the expression relation $\iSim[\Chi]{\Phi}{e_s}{e_t}$ is shown in \fref{fig:sim}; it reads as ``$e_s$ simulates $e_t$ under the postcondition $\Phi$ and protocol $\Chi$''. It expresses that the source $e_s$ can simulate any computation of the target $e_t$ until they both get stuck, both diverge, or reach two expressions in the relational post-condition $\Phi$. The parameter $\Chi$ is the relational protocol that must be followed by function calls in $e_s$ and $e_t$ -- generalizing the Simuliris rule for external calls.

As is standard in Iris, we use a \emph{state interpretation} relation $I(\sigma_s, \sigma_t)$ between source and target states. Recall that in Separation Logic, formulas contain both pure propositions and ressources, which include in particular logical assertions $\loc \mapsto_s v_s$ and $\loc \mapsto_t v_t$ on the physical states. The relation $I(\sigma_s, \sigma_t)$ enforces the consistency of those logical assertions with the physical states $\sigma_s$ and $\sigma_t$.

The definition of the relation itself starts with a double fixpoint, a greatest fixpoint $\nuAbs sim .$ (coinduction) of smallest fixpoint $\muAbs {sim \mathhyphen inner} .$ (induction) of a relation $\mathrm{sim \mathhyphen body}_\Chi$. Inside the relation definition, the cases that use the inductive $sim \mathhyphen inner$ in their recursive occurrence can only be repeated finitely many times, while the cases that use the coinductive $sim$ in their recursive occurrence can be repeated infinitely, but can only do so under a form of guardedness condition.
%
The simulation relation $\mathrm{sim \mathhyphen body}_\Chi$ can relate a source expression $e_s$ and a target expression $e_t$ if, for any source and target heaps that respect some relatedness invariant $I(\sigma_s, \sigma_t)$, .

\clearpage
\input{figures/sim}

The relation between $e_s$ and $e_t$, at a given post-condition $\Phi$, must be parametric over all physical states in the state interpretation relation $I(\sigma_s, \sigma_t)$. It is established by one of the following rules:

\begin{enumerate}
\item[\circled{1}] $e_s$, $e_t$ can stop if they are already in the post-condition $\Phi$ -- and the states are still related.
\item[\circled{2}]
\item[\circled{3}]
\item[\circled{4}]
\item[\circled{5}]
\end{enumerate}

% sim-body:
% cas 1, 2, 3, 4: on raconte
% "ouverte" comprend un autre cas.
% cas 5: les appels externes, protocoles (on raconte)



TODO

\clearpage

\begin{theorem}[Close simulation]
    \begin{align*}
            &
            \iPersistent \left(
                \forall \Psi, e_s, e_t \ldotp
                \Chi (\Psi, e_s, e_t) \iSepImp
                \mathrm{sim \mathhyphen inner}_\bot (\lambdaAbs (\_, e_s', e_t') \ldotp \iSim[\Chi]{\Psi}{e_s'}{e_t'}) (\bot, e_s, e_t)
            \right) \iSepImp
        \\
            &
            \iSim[\Chi]{\Phi}{e_s}{e_t} \iSepImp
            \iSim[\bot]{\Phi}{e_s}{e_t}
    \end{align*}
\end{theorem}

\begin{theorem}[Adequacy]
    $
        \left( \vdash \iSimv{\iSimilar}{e_s}{e_t} \right) \implies
        e_s \refined e_t
    $
\end{theorem}

relational separation logic = simulation

problem: direct calling convention in Simuliris, we need two calling conventions (direct + DPS)

remedy: simulation parameterized by protocol, generalization of Simuliris (but: sequential, without source safety but closed at toplevel)

% X_tmc := X_dir \uplus X_dps

% 1. when we are done
% 2. target stuttering (inductive)
% 3. all one-step source movees
%    3a. no source change (inductive)
%    3b. at least one source reduction (coinductive / guarded)
% 4. "open" simulation; X (\Chi) characterizes admissible foreign calls

% A trick from Simuliris:
% sim-after-progress: instance of sim-inner with bottom in well-chosen places
% closed simulation theorem: if the protocol X is "closable",
%   then the simulation relation for X "collapses" into a closed simulation (bottom for X, no case 4)
%
% MYSTERY: from a high-level perspective this "closd simulation theorem" feels a bit obvious:
% its hypothesis says that your protocol X can always be replaced by making progress on both sides,
% so it should be "easy" to transform a simulation proof using 1-2-3-4 into a simulation proof using only 1-2-3.
%
% Question: if it is "easy", cannot you do this right away (in the proof of simulation for a specific X that satisfies
% this property), proving a closed simulation (without 4) directly?
%
% Clément thinks that the answer is that this would require a super
% tricky coinduction, just like the one used in the proof of this
% theorem.
%
% Clément: this theorem is a sort of coinduction principle. You can
% prove an open simulation by induction (no coinduction
% apparently required), and then applying this theorem gives a result
% for which a direct proof would require a coinduction.

DPS calling convention

TMC protocol

% The X for TMC is essentially a relation/first-order rephrasing of
% the relation specs for direct-style and destination-passing-style
% transformations.

heap bijection

% I(sigma, sigma´) is as in Simuliris, not given explicitly in the current document.
% the \approx^bij relation refers to a component of I (a bijection between addresses)
% that is an implicit parameter of the definitions.

adequacy

% If two expressions refine internally (thy are in the
% simulation relation), and go to the internal equivalence between
% values, then they refine externally (they are in the denotational
% refinement relation).

% This is similar to the Simuliris proof, simplified thanks to the absence
% of concurrency.

simulation rules

% Note: those inference rules are in fact Iris propositions
% (the separating conjunction of the premises magic-wands the conclusion)

% Pure reductions: those that do not need state (neither write nor read)

% Gabriel: we could introduc the non-deterministic pair rules into the "pure" relation
% if we changed the pure-target rule to quantify over all e'_t such that e_t -{pure}-> e'_t.
% This would please Gabriel (existential on the left, universal on the right) and be more compact,
% but Clément prefers the current presentation -- it is more standard for Iris folks -- and closer
% to the mechanization.

% SimBijInsert: \approx^bij: Simuliris calls this the escaped/public
% locations, those that have been published.

% Clément now mentions Figure 12, which shows how stores evolve on an
% example in the TMC case. The shape of the relation between the
% source and target stores is sort of implicit in the program logic
% simulations rules, but it is clear on this example.
%
% Clément would explain this to give an informal sense of the proof,
% before even talking about specification logic etc.

closing simulation

proof


\begin{theorem}[Specification of direct transformation]
    \[
        \iCsimvHoare{
            \wf{e_s} \iSep
            e_s \tmcDir{\xi} e_t
        }{
            \iSimilar
        }{
            e_s
        }{
            e_t
        }
    \]
\end{theorem}

\begin{theorem}[Specification of DPS transformation]
    \[
        \iCsimvHoare{
            \wf{e_s} \iSep
            (\loc, i, e_s) \tmcDps{\xi} e_t \iSep
            (\loc + i) \mapsto \lambdHole
        }{
            \lambdaAbs (v_s, w_t) \ldotp
            \exists v_t \ldotp
            w_t = \lambdUnit \iSep
            (\loc + i) \mapsto v_t \iSep
            v_s \iSimilar v_t
        }{
            e_s
        }{
            e_t
        }
    \]
\end{theorem}

% Those two statements are proven together.
% (First by induction on e_s, then on the two transformation relations mutually-inductively.)

% Note: the \geq here is a "parametric" simulation, we assume that all
% free variables of e_s, e_t (they must be the same) are replaced by
% externally-equivalent values.

% Taking a step back: to prove the contextual refinements between programs,
% we have to check each function,
%   @f vs refined by @f vt  (for vs externally-equiv. vt)
% for this we can use the adequacy lemma
%   f vs simulated by @f vt (for the empty protocol) into internal value equivalence
% and for this we use the simulation closure theorem
%   f vs simulated by @f vt (for the Xtmc protocol)
% assuming the Xtmc protocol is valid/adequate.
%
% But then this is trivial, just use case (4) right away.
% So the meat of the proof is in showing that the Xtmc protocol is valid.

% To prove that the Xtmc propocol is valid:
% - in the direct case, we have a function application on both sides,
%   so we make a pure step on both sides and we have to show that the function bodies
%   (with a bisubstitution (x mapsto (vs, vt)) applied) are in the relation.

\input{figures/sim_rules}
\input{figures/isimilar}
\input{figures/protocol}
\input{figures/csim}

% François: the relational separation logic captures the right
% specification for functions. This is key to compositionality. We
% cannot do this with just a refinement relation. We should emphasize
% that this is a good approach.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
