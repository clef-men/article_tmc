\section{Soundness}

(This paragraph below probably rather belongs to the introduction. Abort.)

The formal contribution of our work is a mechanized soundness proof for the TMC transformation on a simplified programming language, exhibiting the salient parts of the actual transformation for OCaml.
%
The destination-passing style used by the TMC transformation critically relies on uniquely-owned mutable state.
%
It is thus natural to use separation logic as our specification language.

\subsection{Proof outline}

The final theorem we want to establish is a behaviour refinement $p_s \refined p_t$: the behaviours of the transformed program are included in the behaviour of the source program.
%
We propose a notion of behaviour refinement that gives a form of total correctness.
%
It is termination-preserving, but also (this is less common in the body of work around Iris) safety-preserving and divergence-preserving.

Our argument can be split in three separate parts:

\begin{enumerate}

\item The proof technique is a simulation argument, following the approach of Simuliris~\citep*{TODO-simuliris}.
%
We cannot however use Simuliris directly, because it assumes that functions calls have the same structure in the source and target programs.
%
We had to build a modified version of Simuliris, simplified to remove concurrency which does not play a role in our work, but extended to support transformations that change the calling conventions between source and target programs.
%
More precisely, we make our simulation relation $\iSim[\Chi]{\phi}{e_s}{e_t}$ parametric over abstract protocols $\Chi$, extending the technique of \citet*{TODO-paulo} from the unary setting of safety predicates to the binary setting of a relational separation logic.
%
This definition of a simulation relation with protocols is independent
of the TMC language or transformation, and could be reused in other
works.

\item We build a program logic on the TMC language, as a body of lemmas to establish simulations between expressions.

\item Finally we use this program logic to establish the soundness of the TMC transformation.
%
The key ingredents are two specifications for the direct and DPS transformations that are proved in a mutually-inductive way.
\end{enumerate}

\subsection{End goal: behaviour refinement}

The TMC transformation preserves the behavior of programs in a strong sense.
%
We expect terminating programs to remain terminating, diverging programs to remain diverging and failing programs (those that get stuck) to remain failing.

ReLoC~\citep*{TODO-reloc} is focused on terminating behaviors for correct programs.
%
Its behaviour refinement guarantees that if the target program $e_t$ evaluates to $v_t$, then the source program $e_s$ evaluates to a $v_s$ related to $v_t$.

Recent works extend the notion of behaviour refinement to preserve termination.
%
If $e_t$ diverges, then $e_s$ diverges; said otherwise, if $e_s$ reduces to a value,
then $e_t$ reduces to a value or gets stuck.

We further extend behaviour refinement to be safety-preserving: if $e_t$ gets stuck, then $e_s$ can get stuck.
%
As we cover all three possible reduction behaviours, we preserve divergence in the following sense: if a source program $e_s$ can only diverge, then the transformed program must diverge.
%
Note that our language is non-deterministic; if a source program $e_s$ can either converge or diverge, then a $e_t$ that refines $e_s$ could exhibit only a subset of those behaviours.

We define this notion of behaviour refinement $e_s \refined e_t$ in Figure~\ref{fig:refinement}.
%
We define the set $\mathrm{behaviours}_p(e)$ of behaviours of an expression $e$ within a program $p$, starting from an empty store.
%
The behaviour $\constr{Conv}(v_s)$ indicates that $e$ can evaluate to $v_s$.
%
The behaviour $\constr{Conv}(e')$, when $e'$ is not a value, indicates that $e$ can reduce to a stuck configuration $(e', \sigma)$.
%
Finally, $\constr{Div}$ indicates that $e$ can diverge.

We define a refinement relation on behaviours in a natural way: divergence refines divergence, any stuck expression refines any other stuck expression, and a value $v_t$ refines $v_s$ when they are related for a ground equivalence $v_s \similar v_t$, which is the equality for all value kinds, except for locations where it gives no information, as done in Simuliris.
%
This equivalence of ground values could be used, for example, to argue for the correctness of a \texttt{main} function that takes and returns integer arguments.

Finally, an expresion $e_t$ refines $e_s$ when all its behaviours are refined by a behaviour of $e_s$, and a program $p_t$ refines $p_s$ when calls to source functions on equivalent inputs are in the refinement relation.

\input{figures/similar}
\input{figures/refinement}

We can now state the main soundness theorem of our work, whose proof is spread over the rest of this section.

\begin{theorem}[Soundness]
    $
        \wf{p_s} \wedge p_s \tmc p_t \implies
        p_s \refined p_t
    $
\end{theorem}

\subsection{Proof technique: Simuliris with protocols}

TODO

\begin{theorem}[Close simulation]
    \begin{align*}
            &
            \iPersistent \left(
                \forall \Psi, e_s, e_t \ldotp
                \Chi (\Psi, e_s, e_t) \iSepImp
                \mathrm{sim \mathhyphen inner}_\bot (\lambdaAbs (\_, e_s', e_t') \ldotp \iSim[\Chi]{\Psi}{e_s'}{e_t'}) (\bot, e_s, e_t)
            \right) \iSepImp
        \\
            &
            \iSim[\Chi]{\Phi}{e_s}{e_t} \iSepImp
            \iSim[\bot]{\Phi}{e_s}{e_t}
    \end{align*}
\end{theorem}

\begin{theorem}[Adequacy]
    $
        \left( \vdash \iSimv{\iSimilar}{e_s}{e_t} \right) \implies
        e_s \refined e_t
    $
\end{theorem}

relational separation logic = simulation

problem: direct calling convention in Simuliris, we need two calling conventions (direct + DPS)

remedy: simulation parameterized by protocol, generalization of Simuliris (but: sequential, without source safety but closed at toplevel)

% X_tmc := X_dir \uplus X_dps

% 1. when we are done
% 2. target stuttering (inductive)
% 3. all one-step source movees
%    3a. no source change (inductive)
%    3b. at least one source reduction (coinductive / guarded)
% 4. "open" simulation; X (\Khi) characterizes admissible foreign calls

% A trick from Simuliris:
% sim-after-progress: instance of sim-inner with bottom in well-chosen places
% closed simulation theorem: if the protocol X is "closable",
%   then the simulation relation for X "collapses" into a closed simulation (bottom for X, no case 4)
%
% MYSTERY: from a high-level perspective this "closd simulation theorem" feels a bit obvious:
% its hypothesis says that your protocol X can always be replaced by making progress on both sides,
% so it should be "easy" to transform a simulation proof using 1-2-3-4 into a simulation proof using only 1-2-3.
%
% Question: if it is "easy", cannot you do this right away (in the proof of simulation for a specific X that satisfies
% this property), proving a closed simulation (without 4) directly?
%
% Clément thinks that the answer is that this would require a super
% tricky coinduction, just like the one used in the proof of this
% theorem.
%
% Clément: this theorem is a sort of coinduction principle. You can
% prove an open simulation by induction (no coinduction
% apparently required), and then applying this theorem gives a result
% for which a direct proof would require a coinduction.

DPS calling convention

TMC protocol

% The X for TMC is essentially a relation/first-order rephrasing of
% the relation specs for direct-style and destination-passing-style
% transformations.

heap bijection

% I(sigma, sigma´) is as in Simuliris, not given explicitly in the current document.
% the \approx^bij relation refers to a component of I (a bijection between addresses)
% that is an implicit parameter of the definitions.

adequacy

% If two expressions refine internally (thy are in the
% simulation relation), and go to the internal equivalence between
% values, then they refine externally (they are in the denotational
% refinement relation).

% This is similar to the Simuliris proof, simplified thanks to the absence
% of concurrency.

simulation rules

% Note: those inference rules are in fact Iris propositions
% (the separating conjunction of the premises magic-wands the conclusion)

% Pure reductions: those that do not need state (neither write nor read)

% Gabriel: we could introduc the non-deterministic pair rules into the "pure" relation
% if we changed the pure-target rule to quantify over all e'_t such that e_t -{pure}-> e'_t.
% This would please Gabriel (existential on the left, universal on the right) and be more compact,
% but Clément prefers the current presentation -- it is more standard for Iris folks -- and closer
% to the mechanization.

% SimBijInsert: \approx^bij: Simuliris calls this the escaped/public
% locations, those that have been published.

% Clément now mentions Figure 12, which shows how stores evolve on an
% example in the TMC case. The shape of the relation between the
% source and target stores is sort of implicit in the program logic
% simulations rules, but it is clear on this example.
%
% Clément would explain this to give an informal sense of the proof,
% before even talking about specification logic etc.

closing simulation

proof


\begin{theorem}[Specification of direct transformation]
    \[
        \iCsimvHoare{
            \wf{e_s} \iSep
            e_s \tmcDir{\xi} e_t
        }{
            \iSimilar
        }{
            e_s
        }{
            e_t
        }
    \]
\end{theorem}

\begin{theorem}[Specification of DPS transformation]
    \[
        \iCsimvHoare{
            \wf{e_s} \iSep
            (\loc, i, e_s) \tmcDps{\xi} e_t \iSep
            (\loc + i) \mapsto \lambdHole
        }{
            \lambdaAbs (v_s, w_t) \ldotp
            \exists v_t \ldotp
            w_t = \lambdUnit \iSep
            (\loc + i) \mapsto v_t \iSep
            v_s \iSimilar v_t
        }{
            e_s
        }{
            e_t
        }
    \]
\end{theorem}

% Those two statements are proven together.
% (First by induction on e_s, then on the two transformation relations mutually-inductively.)

% Note: the \geq here is a "parametric" simulation, we assume that all
% free variables of e_s, e_t (they must be the same) are replaced by
% externally-equivalent values.

% Taking a step back: to prove the contextual refinements between programs,
% we have to check each function,
%   @f vs refined by @f vt  (for vs externally-equiv. vt)
% for this we can use the adequacy lemma
%   f vs simulated by @f vt (for the empty protocol) into internal value equivalence
% and for this we use the simulation closure theorem
%   f vs simulated by @f vt (for the Xtmc protocol)
% assuming the Xtmc protocol is valid/adequate.
%
% But then this is trivial, just use case (4) right away.
% So the meat of the proof is in showing that the Xtmc protocol is valid.

% To prove that the Xtmc propocol is valid:
% - in the direct case, we have a function application on both sides,
%   so we make a pure step on both sides and we have to show that the function bodies
%   (with a bisubstitution (x mapsto (vs, vt)) applied) are in the relation.



\input{figures/sim}
\input{figures/sim_rules}
\input{figures/isimilar}
\input{figures/protocol}
\input{figures/csim}
